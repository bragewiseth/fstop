{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Renderer","text":"<p>Control, Orient, Manoeuvre, Path Align and Stabilise Spaceflight</p> <p>Welcome to the documentation for project COMPASS, whose objective it is to prepare for rocket  launch in spring 2024. Specifically, the goal of this project is the following:</p> <ul> <li>Integrate and develop testing for Kamlan Filter</li> <li>Integrate projcet with FRAM data bus</li> <li>Have a recovery system for SD-Card data in case of system failure</li> <li>Record/calculate apogee of rocket, and set recovery flag for Recovery Project ... among others</li> </ul> <p>Further details about each goal is or will be documentated further, as well as visualization of how the  project is strung together. Additionally we have in-depth instructions on how we structure and write our code. </p> <p>For further questions, contact Brage, Felix or H\u00e5kon.</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>?\n</code></pre>"},{"location":"#system-architecture","title":"System architecture","text":""},{"location":"API/renderer/","title":"SDCard","text":"<p>The SDCard module has the responsibility of Log flight data to SD-Card card for recovery upon landing,  as well as save Kalman Filter data for landing and for live recovery in case of reboot. Essentially it writes and reads data, the challenge is the format, timing and stability of the system.</p>"},{"location":"API/renderer/#state-driven","title":"State Driven","text":"<p>Currently, the SD-Card class is state-driven code, wherein each state is stored in an enum, and will be changed based on specific conditions</p> <p>Here we can see the different states of the class: <pre><code>  enum SDCARD_STATE {\n    WAIT_SWITCH_PRESS = 0, // Waits for a switch to be pressed to activate SD_Card\n    OPEN_FILE,\n    UPLOAD_FROM_FILE\n    WRITE_TO_FILE,\n    CLOSE_FILE,\n    IDLE,\n    ERROR\n  };\n</code></pre></p> <p>The SD-Card starts at the WAIT_SWITCH_PRESS state, where it waits for the switch to the SD-Card to be turned on</p> <p>Upon being turned on, we will then open the file that the SD-Card reads/writes to</p> <p>Then, we will upload the contents from the file to the Kalman Filter, for more info on this, see: Recovery of Data</p> <p>Thereafter, we will want to be in a state of writing to the file, as we want to store the latest data for either recovery, or for statistics for the ground</p> <p>There is another state for closing the file safely</p> <p>And a state for idling, where we do not want to do anything</p> <p>The last state is the ERROR state, wherein we set an error message and return false to Command Center</p>"},{"location":"API/renderer/#example-state","title":"Example State","text":"<p>Here we enter the WRITE_TO_FILE, where we call the FATFS_write method that is defined by harmony. If the write fails, we enter setError, and give the Callee a chance to call getError() to print the error message we set.</p> <p>If the write goes through, we check if we are done logging. If we are, we close the file. If not, we loop through the  switch case again and re-enter writeToFile(); <pre><code>int utils::SDCard::writeToFile() \n{\n  if (!FATFS_write(sdCard.fileHandle, (const void*) sdCard.buffer, sdCard.nBytesToWrite, &amp;sdCard.nBytesWritten))\n  {\n    setError(\"Failed to: WRITE TO FILE\");\n    return 0;\n  }\n\n\n  // Yet to define how I know if logging is complete\n  if (logComplete())\n    m_CurrentState = CLOSE_FILE;\n\n  return 1;\n}\n</code></pre></p>"},{"location":"API/renderer/#recovery-of-data","title":"Recovery of data","text":"<p>The plan to recover data is to automatically recover it upon starting the proccess. Imagine we are turning it on for the first time, right before a launch. In this case, the SD-Card will be empty, and no data will be loaded.</p> <p>Afterwards, in the hypothetical world where the CPU reboots (which would never happen cause everything will go perfectly), and we need to recover the data, the startup of the SD-Card automatically reboots the data from the SD-Card, which will now have relevant content to  upload.</p> <p>This method allows us several luxuries, as we can avoid several expensive calulations/checks on whether we need to reboot the data or not. It  also saves us alot of development time as we lead up to the 2024 Launch.</p>"},{"location":"about/conventions/","title":"Coding Conventions for Our Project","text":""},{"location":"about/conventions/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Variables</li> <li>Loops</li> <li>If Statements</li> <li>Methods, Functions and Returns</li> </ul>"},{"location":"about/conventions/#variables","title":"Variables","text":"<p>Variable conventions are quite easy to adhere to, but can make a massive difference in how how simple it is to understand code.</p> <p>This is how we declare and use variables:</p> <pre><code>//Normal variable in \"normal\" scope are camelCase\nint thisIsLocalScope;\n\n//It is very useful to separate between local scope variables and \n//member variables, and therefore we write member variables like this, \n//to easily point them out in a sea of calulations\nfloat m_memberVariable;\n\n//This is a constant\nfloat PI = 3.14;\n</code></pre> <p>We also highly value descriptive variable names. In Portal Space, the \"lifespan\" of a member is shorther than a normal company, as we move on after our studies. Therefore we must keep in mind that someone will take over our codebase in relatively short time.</p> <p>If that is not motivation enough for you, try to recall a time you looked back at your own code a month later, and all meaning is lost. Too many times I have been annoyed over my own lazy variable naming conventions</p> <p>Here are some examples: <pre><code>int num = list.length();\n//We already know an integer is a number, what does the number represent? \n// Even though the declaration confirms it is the length of a list, \n//we do not  want to have to look at the declaration of the variable \nevery time we interact with it. \n\n//We can also tell that the name of the list is lackluster. A list of what? -&gt;\nint numberOfEmployees= employees.length();\n\n\n//A bool is often represented as a state of a process, and is used as a check \n//before proceeding with other code, make sure the name of the bool is clear\n//in what it represents.\n\n//Avoid prefixes, they make us think for too long\nif (notDone)\n{\n  //When does this get called? \n  foo();\n}\n\nif (status)\n{\n  // What does 'true' status mean? Is it good or bad? Active or inactive?\n  bar();\n}\n\n//A good example is this:\n\nif (nav.isRunning())\n{\n  //Here we can clearly tell if we reach this point of the code when the CPU is running\n  foo(); \n}\n</code></pre></p> <p>While we are on the topic of booleans, we have a convention of not using the explicit bool datatype, but rather an int.  An integer is false if it equals 0, true if it is non-zero. Negative numbers are non-zero, and evaluated to true. This  is for C++ and C specifically, and defer to documentation of other languages where you are not sure.</p> <pre><code>bool isRunning; //Good name, bad datatype\nint isRunning; //There we go!\n</code></pre>"},{"location":"about/conventions/#loops","title":"Loops","text":"<p>Loops are quite essential in any codebase, there are not very many different ways to format it, but we  prefer to keep the curly braces in line so we can clearly see the scope of the loop. This theme of the curly braces are repeated throughout the codebase</p> <pre><code>//Notice the spacing between the keywords 'for' and ';'\nfor (int i = 0; i &lt; num; i++)\n{\n    //Code goes in here\n}\n</code></pre>"},{"location":"about/conventions/#if-statements","title":"If-Statements","text":"<p>Same as with loops, we like to keep the curly braces in line as to avoid scope confusion.</p> <pre><code>//This\nif (condition)\n{\n  foo();\n}\nelse\n{\n  bar();\n}\n\n//Not this:\nif (condition) {\n  foo();\n} else {\n  bar();\n}\n</code></pre> <p>A very important concept is to avoid indentation as much as possible. If you have several layers of indentation, reconsider your code and try to exit out of loops early.</p> <p>Suppose we have a function that checks if a user has access: <pre><code>void checkAccess(User user, Resource resource)\n{\n    if (user.isAuthenticated())\n    {\n        if (user.isActive())\n        {\n            if (user.hasRole(resource.requiredRole()))\n            {\n                if (!user.accessExpired(resource))\n                {\n                    // Grant access\n                }\n                else\n                {\n                    // Access expired\n                }\n            }\n            else\n            {\n                // Role mismatch\n            }\n        }\n        else\n        {\n            // User is not active\n        }\n    }\n    else\n    {\n        // User is not authenticated\n    }\n}\n</code></pre> As soon as we are a couple indentations too deep, we have way to many variables to keep track of, and  the control flow is way more complex than it needs to be.</p> <p>This is the code refactored, where we try to return early, and handle general cases early. This flattens the  indentations, and makes the code easier to skim over and understand: <pre><code>void canAccess(User user, Resource resource)\n{\n    if (!user.isAuthenticated())\n    {\n        // User is not authenticated\n        return;\n    }\n\n    if (!user.isActive())\n    {\n        // User is not active\n        return;\n    }\n\n    if (!user.hasRole(resource.requiredRole()))\n    {\n        // Role mismatch\n        return;\n    }\n\n    if (user.accessExpired(resource))\n    {\n        // Access expired\n        return;\n    }\n\n    // Grant access\n}\n</code></pre> Immediately we can tell how much easier this is to read and understand in a few glances. It is also beneficial when it comes to debugging, as the control flow is easier and we can tell which condition is not being met faster</p>"},{"location":"about/conventions/#methods-functions-and-returns","title":"Methods, Functions and Returns","text":"<p>Methods and functions have pretty much the same conventions as conditions and loops. We try to keep the function/method as flat as possible, with curly-braces in line and early returns to avoid complex control flow.</p> <p>Additionally, we try to errorproof our code, or at the very last make it clear when we reach an error or not.</p> <pre><code>int canAccess(User user, Resource resource)\n{\n    if (!user.isAuthenticated())\n    {\n        // User is not authenticated\n        printf(\"User is not authenticated\");\n        return 0;\n    }\n\n    if (!user.isActive())\n    {\n        // User is not active\n        printf(\"User is not active\");\n        return 0;\n    }\n\n    if (!user.hasRole(resource.requiredRole()))\n    {\n        // Role mismatch\n        printf(\"User does not have required role\");\n        return 0;\n    }\n\n    if (user.accessExpired(resource))\n    {\n        // Access expired\n        printf(\"User access has expired\");\n        return 0;\n    }\n\n    // Grant access\n    return 1;\n}\n</code></pre> <p>Above we had almost the exact same function as in the proper condition example, except we have added a few perks to make it easier to work with.</p> <ul> <li>Returns a value that indicates if it has gone successfully</li> <li>Prints an error message so we can see what conditions fails first</li> </ul> <p>The return 0 and return 1 are very useful, so we can call the function in a condition, and go from there. </p> <pre><code>if (!canAccess(arg1, arg2))\n{\n  //Means to handle the case of not accessing\n}\n\n//Continue code as expected when granted access...\n</code></pre> <p>Another alternative is to avoid explicitely printing the error message, and give the option instead. Imagine canAccess is a method, and the class it is within has an std::string m_CurrentErrorMessage</p> <p>Notice the correct naming convention of the method and the error message, that make them easy to work with.</p> <p>We use the first condition as an example: <pre><code>if (!user.isAuthenticated())\n    {\n        // User is not authenticated\n        setError(\"User is not authenticated\");\n        return 0;\n    }\n</code></pre></p> <p>And then where we call the method, we can choose whether we print the error or not:</p> <pre><code>if (!(client.canAccess(arg1, arg2)))\n{\n  printf(\"%s\", client.getError.c_str());\n  //Handle further\n\n}\n\n//Continue code as expected when granted access...\n</code></pre>"},{"location":"about/conventions/#classes","title":"Classes","text":"<p>There are many conventions that can be followed to make working with classes easier. This is one of hundreds of ways to make classes easy to read and work with.</p> <p>Below is a live class used in the current project, being the SDCard class, that handles pretty much everything to do with the SDCard.</p> <p>We use #pragma once over header guards, as they are less lines of code, looks prettier and is overall less error prone.</p> <p>In this case, we have a the class wrapped in a namespace, as to not mix common method names, like update with other classes</p> <p>We put public methods followed by public variables at the top. When inspecting a class that you are  unfamiliar with, ordering the public methods and variables first immediately gives you the contents of the class you can directly interact with</p> <p>We have good reason for why some methods and variables are private and some public. The most obvious is  to keep the class safe from outside interference. The other is the layer of abstraction. In this class we have an event driven system. Because of the layout of the class, the callee of the class only needs to call the classes constructor, and the update method at a certain interval. Those two methods take care of all the internal usage of the class, and we dont need to call any other methods.</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n\nnamespace utils {\n\nclass SDCard {\n\n  enum SDCARD_STATE {\n    WAIT_SWITCH_PRESS = 0, // Waits for a switch to be pressed to activate SD_Card\n    OPEN_FILE,\n    WRITE_TO_FILE,\n    CLOSE_FILE,\n    IDLE,\n    ERROR\n  };\n\npublic:\n  // Methods\n  SDCard();\n  int update();\n  std::string getError() { return m_CurrentErrorString; }\n\npublic:\n  // Variables\n\nprivate:\n  // Methods\n  int init(); // Initializes SD_Card\n\n  // Methods to be called upon certain states\n  int waitSwitchPress();\n  int mountDisk();\n  int openFile();\n  int writeToFile();\n  int continueLog();\n  int closeFile();\n  int setIdle();\n  int setError(std::string errorMessage);\n\n  int logComplete() { return m_LogComplete; }\n\nprivate:\n  // Variables\n  SDCARD_STATE m_CurrentState;\n  std::string m_CurrentErrorString = \"\";\n\n  int m_LogComplete;\n};\n\n} // namespace utils\n</code></pre>"},{"location":"devlog/","title":"Feed","text":""},{"location":"devlog/2023/11/30/30-11-2023/","title":"30 11 2023","text":""},{"location":"devlog/2023/11/30/30-11-2023/#early-development","title":"Early Development","text":"<p>The setup of the new game engine is coming along. For now the current goal is to abstract away some functionallity and make the engine more future proof. All the pipline stuff is grouped togheter, the reason beeeing that the pipeline needs information about the different layouts. this allows you to set a layout struct to base every resource around.</p>"},{"location":"wiki/","title":"Wiki","text":"<p>This is the wiki for the project. It contains documentation for the project, and is intended to be a place to store information that is not code, but still relevant to the project. This includes concepts and ideas, as well as</p>"},{"location":"wiki/pixelrenderer/","title":"Pixel","text":""},{"location":"wiki/pixelrenderer/#kalman-filter","title":"Kalman Filter","text":"<p>The Kalman filter is a state estimator that makes an estimate of some unobserved variable based on noisy measurements. It is a recursive filter that is based on the assumption that the state of the system can be described by a linear  stochastic difference equation. The Kalman filter is a powerful tool for combining information in the presence of uncertainty. It is used in a wide range of applications including target tracking, guidance and navigation systems, radar data processing, and satellite orbit determination.</p> <p>For our case we need to estimate the position of the rocket, based on the measurements from the IMU, pressure sensor and magnetometer. In the case of system shutdown, we need to be able to estimate the position of the rocket, based on the last known position and the last known velocity. This is where the Kalman filter comes in. It is a recursive filter, meaning that it can estimate the state of the system based on the previous state and the current measurement. The previous state is stored in an SD-card</p>"},{"location":"devlog/archive/2023/","title":"2023","text":""},{"location":"devlog/category/devlog/","title":"devlog","text":""}]}